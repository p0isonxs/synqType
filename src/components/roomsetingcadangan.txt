import Lottie from "lottie-react";
import { useState, useEffect, useCallback, useMemo } from "react";
import { useNavigate, useLocation } from "react-router";
import { v4 as uuidv4 } from "uuid";
import loadingAnimation from "../assets/loading.json";
import { useUserData } from "../contexts/UserContext";
import { useWeb3 } from "../contexts/Web3Context";
import { useOptimizedBettingContract } from '../hooks/useBettingContract';
import toast from "react-hot-toast";
import {
  FormData,
  RoomMode,
  RoomSettingsProps,
  Theme,
} from "../../type/global";
import { AI_CONTEXTS, THEMES } from "../config/roomsetting";
import { VALIDATION_RULES } from "../validation/roomSettingValidation";

// ✅ Betting validation rules
const BETTING_VALIDATION_RULES = {
  MIN_BET: 0.001,
  MAX_BET: 10,
} as const;

// ✅ Extended FormData interface
interface ExtendedFormData extends FormData {
  betAmount: string;
  enableBetting: boolean;
}

interface RoomSettings {
  sentenceLength: number;
  timeLimit: number;
  maxPlayers: number;
  theme: Theme;
  words: string[];
  enableBetting: boolean;
  betAmount: string;
  roomId: string;
}

export default function OptimizedRoomSettings({ mode: propMode }: RoomSettingsProps) {
  const navigate = useNavigate();
  const location = useLocation();
  const { isConnected } = useWeb3();
  const { playClickSound, updateUserData } = useUserData();
  
  const [loading, setLoading] = useState(false);
  const [mode, setMode] = useState<RoomMode>("multi");
  const [formData, setFormData] = useState<ExtendedFormData>({
    sentenceLength: "",
    timeLimit: "",
    maxPlayers: "",
    theme: "",
    betAmount: "",
    enableBetting: true,
  });

  // ✅ Generate room code early
  const [roomCode] = useState(() => uuidv4().slice(0, 4).toUpperCase());

  // ✅ Use optimized contract hook
  const {
    createRoomAndBet,
    isLoading: isContractLoading,
  } = useOptimizedBettingContract(roomCode, mode === "multi" && isConnected);

  // Determine mode from props or query params
  useEffect(() => {
    if (propMode === "create") {
      setMode("multi");
    } else {
      const params = new URLSearchParams(location.search);
      const selectedMode = params.get("mode");
      setMode(selectedMode === "single" ? "single" : "multi");
    }
  }, [propMode, location.search]);

  // Enhanced form validation
  const validation = useMemo(() => {
    const { sentenceLength, timeLimit, maxPlayers, theme, betAmount, enableBetting } = formData;
    const len = parseInt(sentenceLength);
    const time = parseInt(timeLimit);
    const players = parseInt(maxPlayers);

    const errors: string[] = [];

    if (!theme) errors.push("Please select a theme");
    if (!len || len < VALIDATION_RULES.SENTENCE_LENGTH.min || len > VALIDATION_RULES.SENTENCE_LENGTH.max) {
      errors.push(`Sentence length must be between ${VALIDATION_RULES.SENTENCE_LENGTH.min}–${VALIDATION_RULES.SENTENCE_LENGTH.max} words`);
    }
    if (!time || time < VALIDATION_RULES.TIME_LIMIT.min || time > VALIDATION_RULES.TIME_LIMIT.max) {
      errors.push(`Time limit must be between ${VALIDATION_RULES.TIME_LIMIT.min}–${VALIDATION_RULES.TIME_LIMIT.max} seconds`);
    }
    if (mode === "multi" && (!players || players < VALIDATION_RULES.MAX_PLAYERS.min || players > VALIDATION_RULES.MAX_PLAYERS.max)) {
      errors.push(`Players must be between ${VALIDATION_RULES.MAX_PLAYERS.min}–${VALIDATION_RULES.MAX_PLAYERS.max}`);
    }

    // Betting validations
    if (mode === "multi" && enableBetting) {
      if (!isConnected) {
        errors.push("Connect wallet to create betting room");
      }
      const betValue = parseFloat(betAmount);
      if (!betValue || betValue < BETTING_VALIDATION_RULES.MIN_BET) {
        errors.push(`Minimum bet is ${BETTING_VALIDATION_RULES.MIN_BET} ETH`);
      }
      if (betValue > BETTING_VALIDATION_RULES.MAX_BET) {
        errors.push(`Maximum bet is ${BETTING_VALIDATION_RULES.MAX_BET} ETH`);
      }
    }

    return { isValid: errors.length === 0, errors };
  }, [formData, mode, isConnected]);

  const updateFormData = useCallback((field: keyof ExtendedFormData, value: string | boolean) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  }, []);

  const fetchAIWords = useCallback(async (theme: Theme, sentenceLength: number): Promise<{ sentence: string }> => {
    try {
      const contextKey = theme.toLowerCase() as keyof typeof AI_CONTEXTS;
      const context = AI_CONTEXTS[contextKey] || "";

      const prompt = `Generate EXACTLY ${sentenceLength} words related to ${theme}. Return them as a simple sentence separated by spaces. Respond ONLY with this exact JSON format: {"sentence": "word1 word2 word3..."}`;

      const response = await fetch(import.meta.env.VITE_BACKEND_GEMINI_URL, {
        method: "POST",
        body: JSON.stringify({ prompt }),
        headers: { "Content-Type": "application/json" },
      });

      if (!response.ok) throw new Error("AI fetch failed");
      const data = await response.json();
      return { sentence: data.sentence || "" };
    } catch (error) {
      console.error("Failed to fetch AI sentence:", error);
      toast.error("Failed to fetch AI sentence. Using fallback.");
      return { sentence: "" };
    }
  }, []);

  const processWords = useCallback((sentence: string): string[] => {
    return sentence.split(/\s+/).map((word: string) => word.replace(/[.,!?]/g, "")).filter(Boolean);
  }, []);

  const handleCreate = useCallback(async () => {
    if (!validation.isValid || loading || isContractLoading) {
      toast.error(validation.errors[0] || "Please fix form errors");
      return;
    }

    try {
      playClickSound();
      setLoading(true);

      const len = parseInt(formData.sentenceLength);
      const time = parseInt(formData.timeLimit);
      const players = parseInt(formData.maxPlayers);
      const theme = formData.theme as Theme;

      toast.success("Generating words...");
      const response = await fetchAIWords(theme, len);
      const words = processWords(response.sentence);

      if (mode === "multi" && formData.enableBetting && isConnected) {
        toast.success(`Creating room and placing your ${formData.betAmount} ETH bet...`);
        await createRoomAndBet(formData.betAmount, time);
        toast.success("✅ Room created! You're automatically in the betting pool.", {
          duration: 4000,
          id: 'room-success'
        });
      }

      const settings: RoomSettings = {
        sentenceLength: len,
        timeLimit: time,
        maxPlayers: players,
        theme,
        words,
        enableBetting: mode === "multi" && formData.enableBetting,
        betAmount: formData.betAmount,
        roomId: roomCode,
      };

      updateUserData({ roomSettings: settings });

      if (mode === "single") {
        navigate("/single", { state: settings });
      } else {
        navigate(`/room/${roomCode}/lobby`, { state: settings });
      }
    } catch (error) {
      console.error("Failed to create room:", error);
      toast.error("Failed to create room. Please try again.");
    } finally {
      setLoading(false);
    }
  }, [validation, loading, isContractLoading, formData, mode, isConnected, playClickSound, fetchAIWords, processWords, createRoomAndBet, updateUserData, navigate, roomCode]);

  const handleBack = useCallback(() => {
    const destination = propMode === "create" ? "/multiplayer" : mode === "single" ? "/mode" : "/multiplayer";
    navigate(destination);
  }, [propMode, mode, navigate]);

  const isProcessing = loading || isContractLoading;

  if (isProcessing) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-black text-white">
        <Lottie animationData={loadingAnimation} loop style={{ width: 200, height: 200 }} />
        <p className="mt-4 text-gray-400">
          {isContractLoading ? "Creating room and placing bet..." : "Generating words..."}
        </p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-black flex flex-col">
      {/* Header */}
      <header className="w-full py-6 px-8">
        <div className="flex items-center justify-between">
          <button onClick={handleBack} className="text-gray-400 hover:text-white transition-colors">
            ← Back
          </button>
          <div className="text-center">
            <h1 className="text-2xl font-bold text-white">
              {mode === "single" ? "Solo Settings" : "Room Settings"}
            </h1>
            <p className="text-gray-400 text-sm">
              Room Code: <span className="text-white font-mono">{roomCode}</span>
            </p>
          </div>
          <div></div>
        </div>
      </header>

      {/* Main Content */}
      <div className="flex-1 flex items-center justify-center px-8 py-8">
        <div className="max-w-2xl w-full">
          
          {/* Mode Toggle */}
          {mode === "multi" && (
            <div className="mb-8">
              <div className="grid grid-cols-2 gap-4">
                <button
                  type="button"
                  onClick={() => updateFormData("enableBetting", false)}
                  className={`p-6 rounded-xl border-2 transition-all duration-200 text-center ${
                    !formData.enableBetting
                      ? "border-blue-500 bg-blue-900/20 text-white"
                      : "border-gray-700 bg-gray-800/50 text-gray-300 hover:border-gray-600"
                  }`}
                >
                  <div className="font-semibold mb-2">Normal Mode</div>
                  <div className="text-xs text-gray-400">Free typing battles</div>
                </button>

                <button
                  type="button"
                  onClick={() => updateFormData("enableBetting", true)}
                  className={`p-6 rounded-xl border-2 transition-all duration-200 text-center ${
                    formData.enableBetting
                      ? "border-green-500 bg-green-900/20 text-white"
                      : "border-gray-700 bg-gray-800/50 text-gray-300 hover:border-gray-600"
                  }`}
                >
                  <div className="font-semibold mb-2">Betting Mode</div>
                  <div className="text-xs text-gray-400">Compete for ETH</div>
                </button>
              </div>
            </div>
          )}

          {/* Form */}
          <form onSubmit={(e) => { e.preventDefault(); handleCreate(); }} className="space-y-6">
            
            {/* Betting Amount */}
            {mode === "multi" && formData.enableBetting && (
              <div>
                <label className="block text-white font-medium mb-2">Bet Amount (ETH)</label>
                <input
                  type="number"
                  step="0.001"
                  min={BETTING_VALIDATION_RULES.MIN_BET}
                  max={BETTING_VALIDATION_RULES.MAX_BET}
                  value={formData.betAmount}
                  onChange={(e) => updateFormData("betAmount", e.target.value)}
                  placeholder="0.001"
                  className="w-full px-4 py-3 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-white transition-colors"
                  required
                />
                <p className="text-gray-400 text-xs mt-1">
                  Min: {BETTING_VALIDATION_RULES.MIN_BET} ETH • Max: {BETTING_VALIDATION_RULES.MAX_BET} ETH
                </p>
              </div>
            )}

            {/* Words Count */}
            <div>
              <label className="block text-white font-medium mb-2">Words Count</label>
              <input
                type="number"
                value={formData.sentenceLength}
                onChange={(e) => updateFormData("sentenceLength", e.target.value)}
                placeholder="30"
                className="w-full px-4 py-3 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-white transition-colors"
                required
              />
              <p className="text-gray-400 text-xs mt-1">
                Between {VALIDATION_RULES.SENTENCE_LENGTH.min}–{VALIDATION_RULES.SENTENCE_LENGTH.max} words
              </p>
            </div>

            {/* Time Limit */}
            <div>
              <label className="block text-white font-medium mb-2">Time Limit (seconds)</label>
              <input
                type="number"
                value={formData.timeLimit}
                onChange={(e) => updateFormData("timeLimit", e.target.value)}
                placeholder="60"
                className="w-full px-4 py-3 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-white transition-colors"
                required
              />
              <p className="text-gray-400 text-xs mt-1">
                Between {VALIDATION_RULES.TIME_LIMIT.min}–{VALIDATION_RULES.TIME_LIMIT.max} seconds
              </p>
            </div>

            {/* Max Players */}
            {mode === "multi" && (
              <div>
                <label className="block text-white font-medium mb-2">Max Players</label>
                <input
                  type="number"
                  value={formData.maxPlayers}
                  onChange={(e) => updateFormData("maxPlayers", e.target.value)}
                  placeholder="4"
                  className="w-full px-4 py-3 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-white transition-colors"
                  required
                />
                <p className="text-gray-400 text-xs mt-1">
                  Between {VALIDATION_RULES.MAX_PLAYERS.min}–{VALIDATION_RULES.MAX_PLAYERS.max} players
                </p>
              </div>
            )}

            {/* Theme */}
            <div>
              <label className="block text-white font-medium mb-2">Word Theme</label>
              <select
                value={formData.theme}
                onChange={(e) => updateFormData("theme", e.target.value)}
                className="w-full px-4 py-3 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-white transition-colors"
                required
              >
                <option value="">Select theme...</option>
                {THEMES.map((theme) => (
                  <option key={theme} value={theme}>
                    {theme.charAt(0).toUpperCase() + theme.slice(1)}
                  </option>
                ))}
              </select>
            </div>

            {/* Submit Button */}
            <button
              type="submit"
              disabled={!validation.isValid || isProcessing}
              className="w-full bg-white hover:bg-gray-100 text-black font-semibold py-4 px-8 rounded-lg text-lg transition-all duration-200 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              {mode === "single" ? "Start Solo Challenge" : 
               formData.enableBetting ? `Create Betting Room (${formData.betAmount} ETH)` : "Create Room"}
            </button>
          </form>
        </div>
      </div>

      {/* Footer */}
      <footer className="w-full py-6 px-8 border-t border-gray-800">
        <div className="text-center">
          <p className="text-gray-500 text-sm">
            {mode === "single" ? "Solo Challenge" : formData.enableBetting ? "Betting Mode" : "Normal Mode"}
          </p>
        </div>
      </footer>
    </div>
  );
}